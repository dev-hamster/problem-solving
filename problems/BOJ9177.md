# 단어 섞기

## 접근
BFS

## 코드
```python
import sys
from collections import deque


def bfs(word1, word2, word3):
    q = deque()
    t = 0
    visited = [[False for _ in range(len(word2)+1)]
               for _ in range(len(word1)+1)]

    q.append([0, 0])
    while q:
        # word3 인덱스가 t인 경우의 짝만 확인  
        for _ in range(len(q)):
            # t인 경우의 짝만 확인하기 위해 popleft
            i1, i2 = q.popleft()

            if i1+1 <= len(word1) and not visited[i1+1][i2] and word1[i1] == word3[t]:
                q.append([i1+1, i2])
                visited[i1+1][i2] = True
            if i2+1 <= len(word2) and not visited[i1][i2+1] and word2[i2] == word3[t]:
                q.append([i1, i2+1])
                visited[i1][i2+1] = True
        t += 1

    return t == len(word3)+1


input = sys.stdin.readline

N = int(input())
for i in range(N):
    word1, word2, word3 = map(str, input().split())
    answer = bfs(word1, word2, word3)
    print('Data set {0}: {1}'.format(i+1, 'yes' if answer else 'no'))
```