# 개근상

## 문제
개근상을 받을 수 있는 경우의 수를 구하자. 

개근상을 못 받는 경우
- 연속 결석 3회 
- 지각 2회 이상
  
## 접근
1차 접근(시간초과)
- 백트래킹으로 결석 횟수, 지각 횟수를 카운트해주었다. 

2차 접근(풀이참고)
- dp 배열에 [날짜][지각 횟수][연속 결석 횟수]상태를 저장한다.

## 메모 

## 코드 
```jsx
const filePath =
  process.platform === 'linux'
    ? '/dev/stdin'
    : '';

const input = require('fs')
  .readFileSync(filePath)
  .toString()
  .trim()
  .split('\n');

const solve = (N) => {
  const dp = Array.from({ length: N + 1 }, () =>
    Array.from({ length: 2 }, () => Array.from({ length: 3 }, () => 0))
  );

  dp[1][0][0] = 1;
  dp[1][0][1] = 1;
  dp[1][1][0] = 1;

  for (let i = 1; i <= N - 1; i += 1) {
    // 출석
    dp[i + 1][0][0] =
      (dp[i][0][0] + // 이전 날 출석
        dp[i][0][1] + // 이전 날 결석 1회
        dp[i][0][2]) % // 이전 날 결석 2회
      1000000;

    // 지각 1번한 상태
    dp[i + 1][1][0] =
      (dp[i][0][0] + // 이전 날 출석
        dp[i][0][1] + // 이전 날 결석 1회
        dp[i][0][2] + // 이전 날 결석 2회
        dp[i][1][0] + // 이전 날 지각 1회, 결석 0회
        dp[i][1][1] + // 이전 날 지각 1회, 결석 1회
        dp[i][1][2]) % // 이전 날 지각 1회, 결석 2회
      1000000;

    // 결석 1회
    dp[i + 1][0][1] = dp[i][0][0];

    // 결석 2회
    dp[i + 1][0][2] = dp[i][0][1];

    // 지각 1회, 결석 1회
    dp[i + 1][1][1] = dp[i][1][0];

    // 지각 1회, 결석 2회
    dp[i + 1][1][2] = dp[i][1][1];
  }

  return (
    (dp[N][0][0] +
      dp[N][0][1] +
      dp[N][0][2] +
      dp[N][1][0] +
      dp[N][1][1] +
      dp[N][1][2]) %
    1000000
  );
};

const N = Number(input[0]);
console.log(solve(N));

```
